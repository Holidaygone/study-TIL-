# 웹소켓 (WebSocket)

## 핵심 한 줄 요약:
웹소켓은 웹 브라우저와 서버 간에 지속적인 양방향 통신 채널을 구축할 수 있도록 해주는 통신 프로토콜입니다.

## 더 자세한 설명:

### 1. 왜 웹소켓이 필요할까요? (HTTP의 한계)
우리가 평소에 웹사이트를 이용할 때 주로 사용하는 HTTP(HyperText Transfer Protocol)는 다음과 같은 특징을 가집니다:

* **단방향 통신 (Request-Response Model):** 클라이언트(브라우저)가 서버에게 요청(Request)을 보내야만 서버가 응답(Response)을 보냅니다. 서버가 먼저 클라이언트에게 데이터를 보낼 수는 없습니다.
* **비연결성 (Stateless):** 한 번 요청과 응답이 끝나면 연결이 끊어집니다. 새로운 데이터를 받으려면 클라이언트가 다시 요청을 보내야 합니다.

이러한 HTTP의 특징은 일반적인 웹페이지 조회에는 문제가 없지만, 실시간으로 데이터가 계속해서 주고받아야 하는 서비스 (예: 채팅, 게임, 주식 시세, 실시간 알림)에서는 비효율적입니다.

* **폴링(Polling) 방식:** 클라이언트가 일정 시간마다 계속 서버에 "새로운 데이터 있어요?" 하고 물어보는 방식 (예: 1초마다 요청). 서버에 부하를 주고, 실시간성이 떨어집니다.
* **롱 폴링(Long Polling) 방식:** 클라이언트가 요청을 보내면 서버가 새 데이터가 생길 때까지 응답을 대기하고, 데이터가 생기면 응답을 보냅니다. 클라이언트는 응답을 받으면 다시 요청을 보냅니다. 폴링보다 낫지만 여전히 비효율적입니다.

### 2. 웹소켓의 등장과 장점
HTTP의 이러한 비효율성을 해결하기 위해 등장한 것이 바로 웹소켓입니다.

* **양방향 통신 (Full-Duplex Communication):** 클라이언트와 서버가 한 번 연결되면, 그 연결을 통해 양쪽 모두 언제든지 자유롭게 데이터를 주고받을 수 있습니다. 클라이언트의 요청 없이도 서버가 클라이언트에게 데이터를 보낼 수 있습니다.
* **지속적인 연결 (Persistent Connection):** 한 번 연결이 수립되면, 통신이 끝날 때까지 연결을 계속 유지합니다. 매번 연결을 맺고 끊는 오버헤드가 없습니다.
* **오버헤드 감소:** 연결 수립 후에는 HTTP보다 훨씬 작은 데이터 프레임으로 통신하므로, 네트워크 오버헤드가 적고 효율적입니다.

#### 간단한 비유:
* **HTTP:** 전화 통화와 비슷합니다. 한 사람이 말하면 다른 사람이 듣고, 번갈아가면서 말합니다. 매번 새로운 대화를 시작하려면 전화를 끊고 다시 걸어야 합니다.
* **웹소켓:** 무전기 통화와 비슷합니다. 한 번 연결되면, 양쪽 모두 버튼만 누르면 언제든 상대방에게 말할 수 있고, 상대방도 들을 수 있습니다. 끊지 않는 한 계속 연결되어 있습니다.

### 3. 웹소켓은 어떻게 시작되나요? (핸드셰이크)
웹소켓 연결은 HTTP 요청으로 시작됩니다. 클라이언트가 서버에 "웹소켓 연결을 하고 싶다"는 특별한 HTTP 요청을 보내면, 서버가 이를 승인하여 웹소켓 연결로 "업그레이드"됩니다. 이 과정을 **핸드셰이크(Handshake)**라고 부릅니다. 핸드셰이크가 성공하면 이후부터는 웹소켓 프로토콜로 통신합니다.

---

### 4. WithView 프로젝트에서의 웹소켓 적용
(이 부분에 당신의 `Serverpage.jsx` 코드에서 웹소켓이 어떻게 사용되었는지, 그리고 당신이 어떤 라이브러리(`SockJS`, `STOMP`)를 사용하여 어떤 기능을 구현했는지 구체적으로 작성하세요.)

* **사용 라이브러리 및 역할:**
    * `SockJS`: 웹소켓을 지원하지 않는 구형 브라우저에서도 웹소켓처럼 동작하도록 fallback(대체) 메커니즘을 제공.
    * `STOMP` (`@stomp/stompjs`): 웹소켓 위에서 동작하는 메시징 프로토콜. 메시지를 주고받는 규칙(Pub/Sub 모델)을 제공하여 복잡한 실시간 애플리케이션 개발 용이. (예: `stomp.subscribe`, `stomp.send`)
* **구현 기능 및 코드 연관성:**
    * `/api/sub/server/${serverSeq}` 구독: 서버의 실시간 활동 정보(예: 채널별 인원 수) 수신.
    * `recvMessage` 함수: 수신된 메시지를 파싱하여 `setChannelState`를 통해 React 상태 업데이트 -> UI에 실시간 참여자 수 반영.
    * `connectToServer` 함수: 서버 진입 시 웹소켓 구독 및 입장 메시지 발행.
    * (추가: `Serverpage.jsx`에서 `stomp` 객체를 Redux로 관리한 이유 등 본인이 생각했던 이유/고민을 추가하면 좋습니다.)
* **어려움 및 해결:**
    * (이 부분에 웹소켓 연결 시 겪었던 문제(예: 연결 끊김, 인증 처리)와 해결 방안을 작성하면 더욱 좋습니다.)